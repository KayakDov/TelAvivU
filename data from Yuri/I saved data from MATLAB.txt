I saved data from MATLAB as raw binary, little-endian.

1) Vector file x_f64.bin
Layout:

uint64 n

double x[n]

C++ read:

std::ifstream in("x_f64.bin", std::ios::binary);
uint64_t n; in.read((char*)&n, 8);
std::vector<double> x(n);
in.read((char*)x.data(), 8*n);


2) Sparse matrix file L_csc.bin (CSC format, 0-based indices)
Layout:

uint64 m, uint64 n, uint64 nnz

uint64 colptr[n+1] // pointers into rowind/values

uint32 rowind[nnz] // row indices (0..m-1)

double values[nnz]

Meaning: entries of column j are k = colptr[j] ... colptr[j+1]-1 with (row=rowind[k], col=j, val=values[k]).

C++ read:

std::ifstream in("L_csc.bin", std::ios::binary);
uint64_t m,n,nnz;
in.read((char*)&m,8); in.read((char*)&n,8); in.read((char*)&nnz,8);

std::vector<uint64_t> colptr(n+1);
std::vector<uint32_t> rowind(nnz);
std::vector<double>   val(nnz);

in.read((char*)colptr.data(), 8*(n+1));
in.read((char*)rowind.data(), 4*nnz);
in.read((char*)val.data(),    8*nnz);


If you need CSR instead of CSC, you can convert after reading.

---------------------------------------------------
(2) dx?  Is that the distance between grid points?  I have that as 1.  Does it matter?

I belive it will matter a lot, so I have 1 the total domain length in each direction

and yes Yuris asked me to use my 2D version program first as it is easier to get data from there, just with increased amounts of points

5 diagonal Laplacian, 2000^2 in each matrix dimension

Sorry, it took me some time to rework 2D program to be able to work with a big matricies

now dx = 5.0E-4

I now you do not need L, still I am leaving it also
---------------------------------------------------------
